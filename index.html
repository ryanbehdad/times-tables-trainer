<!doctype html>
<html lang="en-AU">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Times Table Speed Quiz (Minecraft Night)</title>
  <style>
    :root{
      --bg0:#05070f;
      --bg1:#0a0f22;
      --bg2:#0b1a2a;
      --panel: rgba(10, 14, 26, .72);
      --stroke: rgba(255,255,255,.14);
      --text:#f3f6ff;
      --muted: rgba(243,246,255,.75);

      --good:#3bff8b;
      --bad:#ff5c7a;
      --warn:#ffd166;

      --accent:#7c5cff;
      --accent2:#2de2e6;

      --shadow: 0 18px 45px rgba(0,0,0,.55);
      --radius: 16px;
    }

    *{ box-sizing:border-box; }

    /* Dark night Minecraft-ish background: stars + blocky pixel grid */
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color:var(--text);
      padding:18px;

      background:
        /* stars */
        radial-gradient(circle at 10% 20%, rgba(255,255,255,.75) 0 1px, transparent 2px),
        radial-gradient(circle at 25% 70%, rgba(255,255,255,.55) 0 1px, transparent 2px),
        radial-gradient(circle at 60% 30%, rgba(255,255,255,.65) 0 1px, transparent 2px),
        radial-gradient(circle at 78% 85%, rgba(255,255,255,.55) 0 1px, transparent 2px),
        radial-gradient(circle at 90% 15%, rgba(255,255,255,.45) 0 1px, transparent 2px),
        /* subtle ‚Äúnebula‚Äù */
        radial-gradient(900px 650px at 20% 10%, rgba(124,92,255,.20), transparent 60%),
        radial-gradient(900px 650px at 85% 25%, rgba(45,226,230,.12), transparent 62%),
        radial-gradient(900px 650px at 50% 95%, rgba(59,255,139,.08), transparent 62%),
        /* blocky grid */
        repeating-linear-gradient(0deg, rgba(255,255,255,.03), rgba(255,255,255,.03) 2px, transparent 2px, transparent 22px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.02), rgba(255,255,255,.02) 2px, transparent 2px, transparent 22px),
        linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg2));
      background-size:
        420px 420px,
        520px 520px,
        680px 680px,
        760px 760px,
        900px 900px,
        auto, auto, auto,
        auto, auto,
        auto;
      background-blend-mode: screen, screen, screen, screen, screen, normal, normal, normal, normal, normal, normal;
    }

    .app{
      width:min(900px, 100%);
      display:grid;
      gap:14px;
    }

    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    .pill{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border:2px solid rgba(255,255,255,.10);
      background: rgba(7, 10, 20, .60);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      /* pixel-ish corners */
      border-radius: 0;
      clip-path: polygon(
        0 8px, 8px 8px, 8px 0, calc(100% - 8px) 0, calc(100% - 8px) 8px, 100% 8px,
        100% calc(100% - 8px), calc(100% - 8px) calc(100% - 8px), calc(100% - 8px) 100%,
        8px 100%, 8px calc(100% - 8px), 0 calc(100% - 8px)
      );
    }

    select{
      padding:10px 12px;
      border:2px solid rgba(255,255,255,.12);
      background: rgba(10, 15, 35, .65);
      color:var(--text);
      outline:none;
      font-weight:900;
      border-radius: 0;
    }

    button{
      padding:10px 12px;
      border:2px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      color:var(--text);
      cursor:pointer;
      font-weight:1000;
      user-select:none;
      border-radius: 0;
      text-transform: uppercase;
      letter-spacing: .6px;
      box-shadow: 0 10px 22px rgba(0,0,0,.45);
    }

    button.primary{
      background: linear-gradient(135deg, rgba(124,92,255,.70), rgba(45,226,230,.35));
      border-color: rgba(124,92,255,.55);
    }
    button.good{
      background: rgba(59,255,139,.15);
      border-color: rgba(59,255,139,.35);
    }
    button.danger{
      background: rgba(255,92,122,.14);
      border-color: rgba(255,92,122,.35);
    }
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
      box-shadow:none;
    }

    .card{
      border:2px solid rgba(255,255,255,.10);
      background: var(--panel);
      box-shadow: var(--shadow);
      padding:16px;
      border-radius:0;
      position:relative;
      overflow:hidden;
      clip-path: polygon(
        0 10px, 10px 10px, 10px 0, calc(100% - 10px) 0, calc(100% - 10px) 10px, 100% 10px,
        100% calc(100% - 10px), calc(100% - 10px) calc(100% - 10px), calc(100% - 10px) 100%,
        10px 100%, 10px calc(100% - 10px), 0 calc(100% - 10px)
      );
    }

    /* Subtle block texture */
    .card::before{
      content:"";
      position:absolute;
      inset:0;
      opacity:.35;
      pointer-events:none;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,.04), rgba(255,255,255,.04) 1px, transparent 1px, transparent 18px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.03), rgba(255,255,255,.03) 1px, transparent 1px, transparent 18px);
      mix-blend-mode: overlay;
    }

    .status{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:12px;
    }

    .stat{
      position:relative;
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:2px solid rgba(255,255,255,.10);
      background: rgba(7, 10, 20, .55);
      font-weight:1000;
      border-radius:0;
    }
    .stat small{ color: var(--muted); font-weight:900; }

    .timer{
      position:relative;
      width: 260px;
      max-width: 100%;
      height: 14px;
      border:2px solid rgba(255,255,255,.12);
      background: rgba(7, 10, 20, .55);
      overflow:hidden;
    }
    .bar{
      height:100%;
      width:100%;
      background:
        repeating-linear-gradient(90deg,
          rgba(59,255,139,.95) 0 10px,
          rgba(45,226,230,.85) 10px 20px,
          rgba(124,92,255,.85) 20px 30px);
      transform-origin:left;
      transform: scaleX(1);
    }

    .question{
      position:relative;
      display:grid;
      place-items:center;
      text-align:center;
      padding: 10px 6px 6px;
    }

    .big{
      font-size: clamp(3.1rem, 7vw, 5.4rem);
      font-weight: 1000;
      letter-spacing: 1px;
      line-height: 1.05;
      margin: 6px 0 6px;
      text-shadow: 0 14px 26px rgba(0,0,0,.55);
    }

    .hint{
      margin: 0 0 12px;
      color: var(--muted);
      font-weight: 900;
      max-width: 60ch;
    }

    .answerRow{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      padding: 8px 0 6px;
      width:100%;
    }

    input{
      width: min(420px, 100%);
      padding: 14px 16px;
      border:2px solid rgba(255,255,255,.14);
      background: rgba(10, 15, 35, .70);
      color: var(--text);
      outline:none;
      font-size: 1.35rem;
      font-weight: 1000;
      text-align:center;
      border-radius:0;
    }
    input:focus{
      border-color: rgba(45,226,230,.55);
      box-shadow: 0 0 0 4px rgba(45,226,230,.14);
    }

    .feedback{
      min-height: 2.3em;
      text-align:center;
      font-weight: 1000;
      font-size: 1.05rem;
      margin-top: 6px;
      position:relative;
      z-index:1;
    }
    .goodText{ color: var(--good); }
    .badText{ color: var(--bad); }
    .warnText{ color: var(--warn); }

    .controlsRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
      margin-top: 8px;
      position:relative;
      z-index:1;
    }

    .shake{ animation: shake .18s linear 0s 2; }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-6px); }
      50%{ transform: translateX(6px); }
      75%{ transform: translateX(-4px); }
      100%{ transform: translateX(0); }
    }
    .pop{ animation: pop .18s ease-out; }
    @keyframes pop{
      from{ transform: scale(.985); }
      to{ transform: scale(1); }
    }

    .sr-only{
      position:absolute; width:1px; height:1px;
      padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0;
    }
  </style>
</head>

<body>
  <div class="app" role="application" aria-label="Times Table Speed Quiz">
    <div class="top">
      <div class="pill" aria-label="Choose table">
        <span aria-hidden="true">‚õèÔ∏è</span>
        <label class="sr-only" for="baseSel">Table</label>
        <select id="baseSel"></select>
        <span style="color:var(--muted); font-weight:1000;">√ó (1..12)</span>
      </div>

      <div class="pill" aria-label="Controls">
        <button id="startBtn" class="primary">Start</button>
        <button id="restartBtn" class="secondary" type="button">Restart</button>
        <button id="pauseBtn" type="button" disabled>Pause</button>
        <button id="manualBtn" type="button">Manual: Off</button>
      </div>
    </div>

    <div class="card" id="gameCard">
      <div class="status">
        <div class="stat"><span aria-hidden="true">‚úÖ</span><span>Correct</span><small id="correct">0</small></div>
        <div class="stat"><span aria-hidden="true">üß†</span><span>Done</span><small id="done">0/12</small></div>
        <div class="stat"><span aria-hidden="true">‚è±Ô∏è</span><span>Time</span><small id="timeLeft">30s</small></div>

        <div class="timer" aria-label="Time bar">
          <div class="bar" id="bar"></div>
        </div>
      </div>

      <div class="question">
        <div class="big" id="questionText">Pick a table and press Start</div>
        <p class="hint" id="hint">
          You have <strong>30 seconds</strong> per question. Type the answer and press <strong>Enter</strong>.
          After each answer, it shows the correct result and waits up to <strong>15 seconds</strong> (or press <strong>Next</strong>).
        </p>

        <div class="answerRow">
          <label class="sr-only" for="answer">Answer</label>
          <input id="answer" type="number" inputmode="numeric" autocomplete="off" placeholder="Type answer‚Ä¶" disabled />
        </div>

        <div class="feedback" id="feedback" aria-live="polite"></div>

        <div class="controlsRow">
          <button id="nextBtn" class="good" type="button" disabled>Next</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- Minecraft Night: fast quiz, minimal UI, answer reveal, pause + manual mode ---

    const baseSel = document.getElementById("baseSel");
    const startBtn = document.getElementById("startBtn");
    const restartBtn = document.getElementById("restartBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const manualBtn = document.getElementById("manualBtn");
    const nextBtn = document.getElementById("nextBtn");

    const questionText = document.getElementById("questionText");
    const answerInput = document.getElementById("answer");
    const feedback = document.getElementById("feedback");
    const correctEl = document.getElementById("correct");
    const doneEl = document.getElementById("done");
    const timeLeftEl = document.getElementById("timeLeft");
    const bar = document.getElementById("bar");
    const gameCard = document.getElementById("gameCard");

    const PER_QUESTION_SECONDS = 30;
    const REVEAL_WAIT_MS = 15000;
    const MULTIPLIERS = Array.from({length: 12}, (_, i) => i + 1);

    let base = 4;
    let order = [];
    let idx = 0;
    let correct = 0;

    let running = false;

    // Timer state
    let manualMode = false;   // no timer + no pause needed
    let paused = false;
    let tickTimer = null;     // 250ms label + timeout check
    let smoothTimer = null;   // bar animation
    let qEndMs = 0;
    let remainingMs = PER_QUESTION_SECONDS * 1000;

    // Reveal/advance state
    let awaitingNext = false;
    let autoNextTimeout = null;

    function fillTables(){
      baseSel.innerHTML = "";
      for (let n = 1; n <= 12; n++){
        const opt = document.createElement("option");
        opt.value = String(n);
        opt.textContent = String(n);
        if (n === base) opt.selected = true;
        baseSel.appendChild(opt);
      }
    }

    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function stopTimers(){
      if (tickTimer){ clearInterval(tickTimer); tickTimer = null; }
      if (smoothTimer){ clearInterval(smoothTimer); smoothTimer = null; }
    }

    function stopAutoNext(){
      if (autoNextTimeout){ clearTimeout(autoNextTimeout); autoNextTimeout = null; }
    }

    function setFeedback(kind, msg){
      feedback.textContent = msg;
      feedback.className = "feedback " + (kind || "");
      gameCard.classList.remove("shake", "pop");
      gameCard.classList.add(kind === "goodText" ? "pop" : (kind === "badText" ? "shake" : "pop"));
      setTimeout(() => gameCard.classList.remove("shake", "pop"), 260);
    }

    function updateProgress(){
      doneEl.textContent = `${idx}/12`;
      correctEl.textContent = String(correct);
    }

    function setTimeUI(ms){
      if (manualMode){
        timeLeftEl.textContent = "Manual";
        bar.style.transform = "scaleX(1)";
        bar.style.opacity = "0.35";
        return;
      }

      bar.style.opacity = "1";
      const sec = Math.ceil(Math.max(0, ms) / 1000);
      timeLeftEl.textContent = paused ? `Paused (${sec}s)` : `${sec}s`;
      const frac = Math.max(0, ms) / (PER_QUESTION_SECONDS * 1000);
      bar.style.transform = `scaleX(${frac})`;
    }

    function currentMultiplier(){ return order[idx]; }
    function currentAnswer(){ return base * currentMultiplier(); }

    function showQuestion(){
      const m = currentMultiplier();
      questionText.textContent = `${base} √ó ${m} = ?`;
      questionText.classList.add("pop");
      setTimeout(() => questionText.classList.remove("pop"), 220);
    }

    function beginQuestionTimer(){
      stopTimers();
      paused = false;
      pauseBtn.textContent = "Pause";
      pauseBtn.disabled = manualMode;

      if (manualMode){
        remainingMs = PER_QUESTION_SECONDS * 1000;
        setTimeUI(remainingMs);
        return;
      }

      remainingMs = PER_QUESTION_SECONDS * 1000;
      qEndMs = Date.now() + remainingMs;
      setTimeUI(remainingMs);

      // Label & timeout checks (4x per second for snappy pause feel)
      tickTimer = setInterval(() => {
        if (paused) return;
        remainingMs = qEndMs - Date.now();
        setTimeUI(remainingMs);

        if (remainingMs <= 0){
          handleTimeout();
        }
      }, 250);

      // Smooth bar updates
      smoothTimer = setInterval(() => {
        if (paused) return;
        remainingMs = qEndMs - Date.now();
        setTimeUI(remainingMs);
      }, 50);
    }

    function setAwaitingNext(on){
      awaitingNext = on;
      nextBtn.disabled = !on;
      answerInput.disabled = on || !running;
      pauseBtn.disabled = !running || manualMode || on;
    }

    function scheduleAutoNext(){
      stopAutoNext();
      autoNextTimeout = setTimeout(() => {
        if (awaitingNext) goNext();
      }, REVEAL_WAIT_MS);
    }

    function revealThenWait(kind, prefix){
      // Always show the correct equation and answer
      stopTimers();
      stopAutoNext();

      const m = currentMultiplier();
      const ans = currentAnswer();
      const equation = `${base} √ó ${m} = ${ans}`;

      setFeedback(kind, `${prefix}  ${equation}`);
      setAwaitingNext(true);
      scheduleAutoNext();
    }

    function nextQuestion(){
      stopAutoNext();
      stopTimers();

      if (!running) return;

      if (idx >= order.length){
        finish();
        return;
      }

      feedback.textContent = "";
      feedback.className = "feedback";
      answerInput.value = "";
      setAwaitingNext(false);

      showQuestion();
      beginQuestionTimer();
      updateProgress();
      answerInput.focus();
    }

    function startGame(){
      stopAutoNext();
      stopTimers();

      running = true;
      base = Number(baseSel.value || 4);
      order = shuffle([...MULTIPLIERS]);
      idx = 0;
      correct = 0;

      correctEl.textContent = "0";
      doneEl.textContent = "0/12";
      answerInput.value = "";
      setFeedback("", "");
      feedback.textContent = "";
      feedback.className = "feedback";

      pauseBtn.disabled = manualMode;
      setAwaitingNext(false);

      nextQuestion();
    }

    function resetIdle(){
      stopAutoNext();
      stopTimers();

      running = false;
      paused = false;

      base = Number(baseSel.value || 4);
      idx = 0;
      correct = 0;

      correctEl.textContent = "0";
      doneEl.textContent = "0/12";
      questionText.textContent = "Press Start";
      answerInput.value = "";
      answerInput.disabled = true;

      setFeedback("", "");
      feedback.textContent = "";
      feedback.className = "feedback";

      nextBtn.disabled = true;
      pauseBtn.textContent = "Pause";
      pauseBtn.disabled = true;

      setTimeUI(PER_QUESTION_SECONDS * 1000);
    }

    function submitAnswer(){
      if (!running || awaitingNext) return;

      const raw = answerInput.value;
      if (raw === "" || raw === null) return;

      const guess = Number(raw);
      const ans = currentAnswer();

      // Mark and advance idx now; reveal uses current question values, so reveal before idx++?
      // We need current multiplier for message, so reveal first then increment after.
      const isRight = guess === ans;

      if (isRight){
        correct += 1;
        revealThenWait("goodText", "‚úÖ Correct!");
      } else {
        revealThenWait("badText", "‚ùå Not quite.");
      }

      idx += 1;
      updateProgress();
    }

    function handleTimeout(){
      if (!running || awaitingNext) return;

      revealThenWait("badText", "‚è≥ Time!");
      idx += 1;
      updateProgress();
    }

    function goNext(){
      if (!running || !awaitingNext) return;
      setAwaitingNext(false);
      nextQuestion();
    }

    function togglePause(){
      if (!running || manualMode || awaitingNext) return;

      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";

      if (!manualMode){
        if (paused){
          // freeze remaining
          remainingMs = Math.max(0, qEndMs - Date.now());
          setTimeUI(remainingMs);
        } else {
          // resume from remaining
          qEndMs = Date.now() + Math.max(0, remainingMs);
          setTimeUI(Math.max(0, remainingMs));
        }
      }
    }

    function toggleManual(){
      manualMode = !manualMode;
      manualBtn.textContent = manualMode ? "Manual: On" : "Manual: Off";

      // If running, immediately apply behaviour:
      if (running && !awaitingNext){
        // stop any timer and switch UI
        stopTimers();
        paused = false;
        pauseBtn.textContent = "Pause";
        pauseBtn.disabled = manualMode;
        beginQuestionTimer(); // will no-op timers in manual mode and update UI
      } else {
        pauseBtn.disabled = true;
        setTimeUI(PER_QUESTION_SECONDS * 1000);
      }
    }

    function finish(){
      stopAutoNext();
      stopTimers();

      running = false;
      paused = false;

      answerInput.disabled = true;
      nextBtn.disabled = true;
      pauseBtn.disabled = true;
      pauseBtn.textContent = "Pause";

      const msg =
        correct === 12 ? "üåü PERFECT! 12/12" :
        correct >= 10 ? `üî• EPIC! ${correct}/12` :
        correct >= 7  ? `üôå NICE! ${correct}/12` :
        `üëç GOOD TRY! ${correct}/12`;

      questionText.textContent = msg;
      setFeedback("warnText", "Press Restart to shuffle and play again.");
      doneEl.textContent = "12/12";
      setTimeUI(0);
    }

    // --- User actions ---
    baseSel.addEventListener("change", () => {
      if (!running) resetIdle();
    });

    startBtn.addEventListener("click", startGame);
    restartBtn.addEventListener("click", startGame);
    pauseBtn.addEventListener("click", togglePause);
    manualBtn.addEventListener("click", toggleManual);
    nextBtn.addEventListener("click", goNext);

    answerInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter"){
        if (awaitingNext) goNext();
        else submitAnswer();
      }
    });

    // Handy: press Space anywhere to go Next when revealing
    document.addEventListener("keydown", (e) => {
      if (e.key === " " && awaitingNext){
        e.preventDefault();
        goNext();
      }
      // Also allow Enter anywhere to go Next while revealing
      if (e.key === "Enter" && awaitingNext && document.activeElement !== answerInput){
        goNext();
      }
    });

    // --- Init ---
    (function init(){
      fillTables();
      resetIdle();
    })();
  </script>
</body>
</html>
